[[plugins]]
repo = 'Shougo/dein.vim'
hook_add = '''
    let g:dein#auto_recache = v:true
'''

[[plugins]]
repo = 'sainnhe/sonokai'

[[plugins]]
repo = 'nvim-lua/plenary.nvim'

[[plugins]]
repo = 'nvim-lua/popup.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope.nvim'
on_lua = 'telescope'
hook_add = '''
    nnoremap <M-b> <Cmd>lua require('telescope.builtin').buffers {ignore_current_buffer = true, sort_lastused = true}<CR>
    nnoremap <M-f> <Cmd>lua require('telescope.builtin').find_files {follow = true, hidden = true}<CR>
    nnoremap <M-F> <Cmd>lua require('telescope.builtin').file_browser {}<CR>
    nnoremap <M-g> <Cmd>lua require('telescope.builtin').current_buffer_fuzzy_find {}<CR>
    nnoremap <M-G> <Cmd>lua require('telescope.builtin').live_grep {}<CR>
    nnoremap <M-t> <Cmd>lua require('telescope.builtin').treesitter {}<CR>
'''
hook_source = '''
    lua <<EOF
        require'telescope'.setup {
            defaults = {
                mappings = {
                    i = {
                        ['<Esc>'] = 'close',
                    },
                },
            },
        }
EOF
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
rev = '0.5-compat'
on_event = 'BufRead'
hook_source = '''
    lua <<EOF
        require'nvim-treesitter.configs'.setup {
            ensure_installed = 'maintained',
            ignore_install = {},
            highlight = {
                enable = true,
                disable = {},
            },
            incremental_selection = {
                enable = true,
                keymaps = {
                    node_incremental = 'J',
                    node_decremental = 'K',
                },
            },
            indent = {
                enable = true,
            },
        }
EOF
'''
hook_post_update = '''
    TSUpdate
'''

[[plugins]]
repo = 'sheerun/vim-polyglot'
hook_add = '''
    let g:polyglot_disabled = ['sensible']

    let g:vim_markdown_frontmatter = 1
'''

[[plugins]]
repo = 'vim-scripts/sudo.vim'
on_path = '^sudo:'

[[plugins]]
repo = 'scrooloose/nerdcommenter'
hook_add = '''
    let g:NERDCommentWholeLinesInVMode = 1
    let g:NERDSpaceDelims = 1
    let g:NERDDefaultAlign = 'left'
    let g:NERDCustomDelimiters = {
        \ 'c': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
        \ 'arduino': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
        \ }
'''
hook_post_source = '''
    nmap # <Plug>NERDCommenterToggle
    vmap # <Plug>NERDCommenterToggle
'''

[[plugins]]
repo = 'cohama/lexima.vim'
hook_add = '''
    " Do not map <Esc> automatically
    let g:lexima_map_escape = ''
'''
hook_post_source = '''
    call lexima#set_default_rules()

    call lexima#add_rule({'char': '(', 'at': '\%#\w'})
    call lexima#add_rule({'char': '{', 'at': '\%#\w'})
    call lexima#add_rule({'char': '[', 'at': '\%#\w'})
    call lexima#add_rule({'char': '"', 'at': '\%#\w'})
    call lexima#add_rule({'char': "'", 'at': '\%#\w'})
    call lexima#add_rule({'char': '`', 'at': '\%#\w'})

    call lexima#add_rule({'char': '<CR>', 'at': '"""\%#"""', 'input_after': '<CR>'})
    call lexima#add_rule({'char': '<CR>', 'at': '"""\%#$', 'input_after': '<CR>)', 'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1""""'})
    call lexima#add_rule({'char': '<CR>', 'at': "''" . "'\\%#'" . "''", 'input_after': '<CR>'})
    call lexima#add_rule({'char': '<CR>', 'at': "''" . "'\\%#$", 'input_after': '<CR>}', 'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' + "''" . "'"})
    call lexima#add_rule({'char': '<CR>', 'at': '```\%#```', 'input_after': '<CR>'})
    call lexima#add_rule({'char': '<CR>', 'at': '```\%#$', 'input_after': '<CR>]', 'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1```'})

    " Do not complete whenever popup menu is visible
    inoremap <CR> <C-g>u<C-r>=lexima#expand('<lt>CR>', 'i')<CR>
    " Close popup before calling `lexima#insmode#escape()`
    inoremap <expr> <Esc> (pumvisible() ? '<C-e>' : '') . lexima#insmode#escape() . '<Esc>'
'''

[[plugins]]
repo = 'tpope/vim-surround'
hook_add = '''
    let g:surround_{char2nr('c')} = "\\\1command: \1{\r}"
    let g:surround_{char2nr('C')} = "\\\1command: \1{\n\r\n}"
'''

[[plugins]]
repo = 'phaazon/hop.nvim'
on_lua = 'hop'
hook_add = '''
    nnoremap <silent> s <Cmd>lua require'hop'.hint_char2()<CR>
    xnoremap <silent> s <Cmd>lua require'hop'.hint_char2()<CR>
'''
hook_source = '''
    lua <<EOF
        require'hop'.setup {
            create_hl_autocmd = true,
        }
EOF
'''

[[plugins]]
repo = 'tpope/vim-speeddating'

[[plugins]]
repo = 'tpope/vim-repeat'

[[plugins]]
repo = 'dhruvasagar/vim-table-mode'
hook_add = '''
    " let g:table_mode_corner_corner = '+'
    " let g:table_mode_header_fillchar = '='
'''

[[plugins]]
repo = 'L3MON4D3/LuaSnip'
on_lua = 'luasnip'

[[plugins]]
repo = 'hrsh7th/nvim-compe'
on_event = 'InsertEnter'
hook_source = '''
    lua <<EOF
        vim.o.completeopt = 'menuone,noselect'

        require'compe'.setup {
            preselect = 'always',
            documentation = {
                border = 'rounded',
            },
            source = {
                path = {
                    kind = ' ',
                },
                buffer = {
                    kind = ' ',
                    menu = '[B]',
                },
                calc = {
                    kind = ' ',
                },
                nvim_lsp = true,
                nvim_lua = true,
            },
        }

        local regex_start_with_nonspace = vim.regex([[^\S]])
        _G.super_tab = function()
            if vim.fn.pumvisible() ~= 0 then
                local break_undo = vim.api.nvim_replace_termcodes('<C-g>u', true, true, true)
                return break_undo .. vim.fn['compe#confirm']('<Tab>')
            end

            local row, col = unpack(vim.api.nvim_win_get_cursor(0))
            if col > 0 and regex_start_with_nonspace:match_line(0, row - 1, col - 1) then
                return vim.fn['compe#complete']()
            end

            return vim.api.nvim_replace_termcodes('<Tab>', true, true, true)
        end

        local opts = {
            noremap = true,
            silent = true,
            expr = true,
        }

        vim.api.nvim_set_keymap('i', '<Tab>', [[v:lua.super_tab()]], opts)
        vim.api.nvim_set_keymap('i', '<C-g>', [[compe#close('')]], opts)
EOF
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'
# Initialize after `:syntax enable` to do LSP formatting correctly
on_event = 'VimEnter'
hook_source = '''
    lua <<EOF
        local nvim_lsp = require'lspconfig'

        -- This can override in project configuration
        vim.g.autoformat_disable_ft = {}

        function autoformat()
            local function to_bool(x)
                return x and x ~= 0
            end

            if to_bool(vim.b.autoformat_disable) then
                return
            end

            if not to_bool(vim.b.autoformat_enable) then
                if vim.tbl_contains(vim.g.autoformat_disable_ft, vim.bo.filetype) then
                    return
                end

                if not vim.tbl_contains(vim.g.autoformat_enable_ft, vim.bo.filetype) then
                    return
                end
            end

            vim.lsp.buf.formatting_sync(nil, 1000)
        end

        local function on_attach(client, bufnr)
            local function buf_set_keymap(...)
                vim.api.nvim_buf_set_keymap(bufnr, ...)
            end

            local opts = {
                noremap = true,
                silent = true,
            }

            buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
            buf_set_keymap('n', 'gD', '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
            buf_set_keymap('n', 'gi', '<Cmd>lua vim.lsp.buf.implementation()<CR>', opts)
            buf_set_keymap('n', 'g<C-d>', '<Cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
            buf_set_keymap('n', 'gn', '<Cmd>lua vim.lsp.buf.rename()<CR>', opts)
            buf_set_keymap('n', 'gr', '<Cmd>lua vim.lsp.buf.reference()<CR>', opts)
            buf_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
            buf_set_keymap('n', '<C-k>', '<Cmd>lua vim.lsp.buf.signature_help()<CR>', opts)

            buf_set_keymap('n', 'gf', '<Cmd>lua vim.lsp.buf.formatting()<CR>', opts)
            buf_set_keymap('x', 'gf', '<Cmd>lua vim.lsp.buf.range_formatting()<CR>', opts)

            buf_set_keymap('n', '<Leader>a', '<Cmd>lua vim.lsp.buf.code_action()<CR>', opts)

            buf_set_keymap('n', '[d', '<Cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
            buf_set_keymap('n', ']d', '<Cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
            buf_set_keymap('x', '[d', '<Cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
            buf_set_keymap('x', ']d', '<Cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)

            vim.b.autoformat_disable = false
            vim.b.autoformat_enable = false

            vim.cmd [[
                augroup config_lsp_buf
                    autocmd!
                    autocmd BufWritePre <buffer> lua autoformat()
                augroup end
            ]]

            vim.lsp.handlers['textDocument/hover'] =
                vim.lsp.with(vim.lsp.handlers.hover, { border = 'rounded' })
            vim.lsp.handlers['textDocument/signatureHelp'] =
                vim.lsp.with(vim.lsp.handlers.signature_help, { border = 'rounded' })
        end

        local settings = {}

        local servers = {
            clangd = {},
            pyright = {},
            rust_analyzer = {},
            efm = {
                filetypes = { 'python' },
                init_options = {
                    documentFormatting = true,
                },
                settings = {
                    rootMarkers = { '.git' },
                    languages = {
                        python = {
                            {
                                formatCommand = 'black --quiet -',
                                formatStdin = true,
                            },
                        },

                    },
                },
            },
        }

        vim.g.autoformat_enable_ft = {
            'c',
            'cpp',
            'python',
            'rust',
        }

        for lsp, params in pairs(servers) do
            nvim_lsp[lsp].setup(vim.tbl_deep_extend('keep', params, {
                on_attach = on_attach,
                settings = settings,
            }))
        end

        local signs = {
            Error = ' ',
            Warning = ' ',
            Hint = ' ',
            Information = ' ',
        }

        for type, text in pairs(signs) do
            local hl = 'LspDiagnosticsSign' .. type
            vim.fn.sign_define(hl, { text = text, texthl = hl, numhl = '' })
        end

        local kinds = {
            Text          = ' ',
            Method        = ' ',
            Function      = 'ƒ ',
            Constructor   = ' ',
            Field         = ' ',
            Variable      = ' ',
            Class         = ' ',
            Interface     = ' ',
            Module        = ' ',
            Property      = ' ',
            Unit          = ' ',
            Value         = ' ',
            Enum          = ' ',
            Keyword       = ' ',
            Snippet       = ' ',
            Color         = ' ',
            File          = ' ',
            Reference     = ' ',
            Folder        = ' ',
            EnumMember    = ' ',
            Constant      = ' ',
            Struct        = ' ',
            Event         = ' ',
            Operator      = ' ',
            TypeParameter = ' ',
        }

        for name, str in pairs(kinds) do
            if vim.lsp.protocol.CompletionItemKind[name] ~= nil then
                vim.lsp.protocol.CompletionItemKind[vim.lsp.protocol.CompletionItemKind[name]] = str
            end
        end
EOF
'''

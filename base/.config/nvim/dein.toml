[[plugins]]
repo = 'Shougo/dein.vim'
hook_add = '''
    let g:dein#auto_recache = v:true
'''

[[plugins]]
repo = 'sainnhe/sonokai'
hook_add = '''
    function! s:colorscheme_override() abort
        highlight! link NormalFloat TelescopeNormal
        highlight! link FloatBorder TelescopeBorder
    endfunction

    augroup config_colorscheme
        autocmd VimEnter * nested colorscheme sonokai
        autocmd ColorScheme sonokai call s:colorscheme_override()
    augroup end
'''

[[plugins]]
repo = 'kyazdani42/nvim-web-devicons'
on_lua = 'nvim-web-devicons'

[[plugins]]
repo = 'hoob3rt/lualine.nvim'
on_event = 'ColorScheme'
hook_source = '''
    lua <<EOF
        local theme_name = 'sonokai'

        -- Convert lightline theme to lualine's
        -- See https://gist.github.com/shadmansaleh/000871c9a608a012721c6acc6d7a19b9

        -- Use `nvim_eval` to autoload variable
        local lightline_palette =
            vim.api.nvim_eval('g:lightline#colorscheme#' .. theme_name .. '#palette')

        local theme = {}
        for mode, section in pairs(lightline_palette) do
            theme[mode] = {}

            local function set(name, colors)
                theme[mode][name] = {
                    fg = colors[1],
                    bg = colors[2],
                }
                if #colors >= 5 then
                    theme[mode][name].gui = colors[5]
                end
            end

            set('a', section.left[1])
            if section.left[2] then
                set('b', section.left[2])
            elseif section.right then
                set('b', section.right[1])
            end
            if section.middle then
                set('c', section.middle[1])
            end
        end

        local sections = {
            lualine_a = {
                '" "',
            },
            lualine_b = {
                {
                    'filename',
                    path = 1, -- relative path
                },
            },
            lualine_c = {
                'branch',
                'diff',
                {
                    'diagnostics',
                    sources = { 'nvim_lsp' },
                },
            },
            lualine_x = {
                'encoding',
                'fileformat',
                'filetype',
            },
            lualine_y = {
                'location',
                'vim.api.nvim_buf_line_count(0)',
                'progress',
            },
            lualine_z = {
                '" "',
            },
        }

        local inactive_sections = vim.deepcopy(sections)
        inactive_sections.lualine_c = {}

        require'lualine'.setup {
            options = {
                section_separators = { '', '' },
                component_separators = { '', '' },
                theme = theme,
            },
            sections = sections,
            inactive_sections = inactive_sections,
        }
EOF
'''

[[plugins]]
repo = 'nvim-lua/plenary.nvim'
on_lua = 'plenary'

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
hook_add = '''
    lua <<EOF
        require('gitsigns').setup {}
EOF
'''

[[plugins]]
repo = 'nvim-lua/popup.nvim'
on_lua = 'popup'

[[plugins]]
repo = 'nvim-telescope/telescope.nvim'
on_lua = 'telescope'
hook_add = '''
    nnoremap <M-b> <Cmd>lua require('telescope.builtin').buffers {ignore_current_buffer = true, sort_lastused = true}<CR>
    nnoremap <M-f> <Cmd>lua require('telescope.builtin').find_files {follow = true, hidden = true}<CR>
    nnoremap <M-F> <Cmd>lua require('telescope.builtin').file_browser {}<CR>
    nnoremap <M-g> <Cmd>lua require('telescope.builtin').current_buffer_fuzzy_find {}<CR>
    nnoremap <M-G> <Cmd>lua require('telescope.builtin').live_grep {}<CR>

    nnoremap <Leader>gc <Cmd>lua require('telescope.builtin').git_bcommits {}<CR>
    nnoremap <Leader>gC <Cmd>lua require('telescope.builtin').git_commits {}<CR>
    nnoremap <Leader>gs <Cmd>lua require('telescope.builtin').git_status {}<CR>
    nnoremap <Leader>gb <Cmd>lua require('telescope.builtin').git_branches {}<CR>
'''
hook_source = '''
    lua <<EOF
        local function preview_scrolling_lines(lines)
            local action_state = require'telescope.actions.state'

            return function(prompt_buffer)
                local previewer = action_state.get_current_picker(prompt_buffer).previewer
                if type(previewer) ~= 'table' or not previewer.scroll_fn then
                    return
                end

                previewer:scroll_fn(lines)
            end
        end

        require'telescope'.setup {
            defaults = {
                scroll_strategy = 'limit',
                mappings = {
                    i = {
                        ['<Esc>'] = 'close',
                        ['<C-e>'] = preview_scrolling_lines(3),
                        ['<C-y>'] = preview_scrolling_lines(-3),
                    },
                },
            },
        }
EOF
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
rev = '0.5-compat'
on_event = ['BufNew', 'BufRead']
hook_source = '''
    " Loading external modules (such as `nvim-treesitter-textobjects`)
    "
    " Required load order:
    " 1. Add `nvim-treesitter` into lua `package.path`
    " 2. Load `MODULE_PLUGIN.vim` to call `init` of the module
    " 3. Call `setup` of `nvim-treesitter` with `MODULE = { enable = true }`
    "
    " 1 and 2 can be done by specifying same `on_*` to `nvim-treesitter` to the plugin of the module

    lua <<EOF
        require'nvim-treesitter.configs'.setup {
            ensure_installed = 'maintained',
            ignore_install = {},
            highlight = {
                enable = true,
                disable = {},
            },
            incremental_selection = {
                enable = true,
                keymaps = {
                    init_selection = '<Plug>(treesitter-init-selection)',
                    node_incremental = 'J',
                    scope_incremental = '<Plug>(treesitter-scope-incremental)',
                    node_decremental = 'K',
                },
            },
            textobjects = {
                select = {
                    enable = true,
                    lookahead = true,
                    keymaps = {
                        ['ib'] = '@block.inner',
                        ['ab'] = '@block.outer',
                        ['ij'] = '@call.inner',
                        ['aj'] = '@call.outer',
                        ['iy'] = '@class.inner',
                        ['ay'] = '@class.outer',
                        ['ao'] = '@comment.outer',
                        ['ii'] = '@conditional.inner',
                        ['ai'] = '@conditional.outer',
                        ['iF'] = '@frame.inner',
                        ['aF'] = '@frame.outer',
                        ['if'] = '@function.inner',
                        ['af'] = '@function.outer',
                        ['il'] = '@loop.inner',
                        ['al'] = '@loop.outer',
                        ['ia'] = '@parameter.inner',
                        ['aa'] = '@parameter.outer',
                        ['as'] = '@statement.outer',
                    },
                },
                move = {
                    enable = true,
                    goto_next_start = {
                        [']b'] = '@block.inner',
                        [']j'] = '@call.outer',
                        [']y'] = '@class.outer',
                        [']o'] = '@comment.outer',
                        [']i'] = '@conditional.outer',
                        [']f'] = '@function.outer',
                        [']l'] = '@loop.outer',
                        [']a'] = '@parameter.inner',
                        [']s'] = '@statement.outer',
                    },
                    goto_next_end = {
                        [']B'] = '@block.inner',
                        [']J'] = '@call.outer',
                        [']Y'] = '@class.outer',
                        [']O'] = '@comment.outer',
                        [']I'] = '@conditional.outer',
                        [']F'] = '@function.outer',
                        [']L'] = '@loop.outer',
                        [']A'] = '@parameter.inner',
                        [']S'] = '@statement.outer',
                    },
                    goto_previous_start = {
                        ['[b'] = '@block.inner',
                        ['[j'] = '@call.outer',
                        ['[y'] = '@class.outer',
                        ['[o'] = '@comment.outer',
                        ['[i'] = '@conditional.outer',
                        ['[f'] = '@function.outer',
                        ['[l'] = '@loop.outer',
                        ['[a'] = '@parameter.inner',
                        ['[s'] = '@statement.outer',
                    },
                    goto_previous_end = {
                        ['[B'] = '@block.inner',
                        ['[J'] = '@call.outer',
                        ['[Y'] = '@class.outer',
                        ['[O'] = '@comment.outer',
                        ['[I'] = '@conditional.outer',
                        ['[F'] = '@function.outer',
                        ['[L'] = '@loop.outer',
                        ['[A'] = '@parameter.inner',
                        ['[S'] = '@statement.outer',
                    },
                },
            },
        }
EOF
'''
hook_post_update = '''
    TSUpdate
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter-textobjects'
rev = '0.5-compat'
on_event = ['BufNew', 'BufRead']

[[plugins]]
repo = 'sheerun/vim-polyglot'
hook_add = '''
    let g:polyglot_disabled = ['sensible']

    let g:vim_markdown_frontmatter = 1
'''

[[plugins]]
repo = 'vim-scripts/sudo.vim'
on_path = '^sudo:'

[[plugins]]
repo = 'scrooloose/nerdcommenter'
on_map = '<Plug>NERDCommenter'
hook_add = '''
    nmap # <Plug>NERDCommenterToggle
    xmap # <Plug>NERDCommenterToggle
'''
hook_source = '''
    let g:NERDCommentWholeLinesInVMode = 1
    let g:NERDSpaceDelims = 1
    let g:NERDDefaultAlign = 'left'
    let g:NERDCustomDelimiters = {
        \ 'c': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
        \ 'arduino': { 'left': '//', 'leftAlt': '/*', 'rightAlt': '*/' },
        \ }
'''

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = 'InsertEnter'
hook_source = '''
    " Do not map <Esc> automatically
    let g:lexima_map_escape = ''
'''
hook_post_source = '''
    call lexima#set_default_rules()

    call lexima#add_rule({'char': '(', 'at': '\%#\w'})
    call lexima#add_rule({'char': '{', 'at': '\%#\w'})
    call lexima#add_rule({'char': '[', 'at': '\%#\w'})
    call lexima#add_rule({'char': '"', 'at': '\%#\w'})
    call lexima#add_rule({'char': "'", 'at': '\%#\w'})
    call lexima#add_rule({'char': '`', 'at': '\%#\w'})

    call lexima#add_rule({'char': '<CR>', 'at': '"""\%#"""', 'input_after': '<CR>'})
    call lexima#add_rule({'char': '<CR>', 'at': '"""\%#$', 'input_after': '<CR>)', 'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1""""'})
    call lexima#add_rule({'char': '<CR>', 'at': "''" . "'\\%#'" . "''", 'input_after': '<CR>'})
    call lexima#add_rule({'char': '<CR>', 'at': "''" . "'\\%#$", 'input_after': '<CR>}', 'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' + "''" . "'"})
    call lexima#add_rule({'char': '<CR>', 'at': '```\%#```', 'input_after': '<CR>'})
    call lexima#add_rule({'char': '<CR>', 'at': '```\%#$', 'input_after': '<CR>]', 'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1```'})

    " Do not complete whenever popup menu is visible
    inoremap <silent> <CR> <C-]><C-g>u<C-r>=lexima#expand('<lt>CR>', 'i')<CR>
    " Close popup before calling `lexima#insmode#escape()`
    inoremap <silent><expr> <Esc> compe#close() . lexima#insmode#escape() . '<Esc>'
'''

[[plugins]]
repo = 'tpope/vim-surround'
on_event = 'VimEnter'
hook_source = '''
    let g:surround_{char2nr('c')} = "\\\1command: \1{\r}"
    let g:surround_{char2nr('C')} = "\\\1command: \1{\n\r\n}"

    let g:surround_no_mappings = v:true

    nmap ds <Plug>Dsurround
    nmap cs <Plug>Csurround
    nmap cS <Plug>CSurround
    nmap ys <Plug>Ysurround
    nmap yS <Plug>YSurround
    nmap yss <Plug>Yssurround
    nmap ySs <Plug>YSsurround
    nmap ySS <Plug>YSsurround

    " Change to avoid conflicting with Hop
    xmap gs <Plug>VSurround
    xmap gS <Plug>VgSurround
'''

[[plugins]]
repo = 'phaazon/hop.nvim'
on_lua = 'hop'
hook_add = '''
    nnoremap <silent> s <Cmd>lua require'hop'.hint_char2()<CR>
    xnoremap <silent> s <Cmd>lua require'hop'.hint_char2()<CR>
    nnoremap <silent> S <Cmd>lua require'hop'.hint_lines()<CR>
    xnoremap <silent> S <Cmd>lua require'hop'.hint_lines()<CR>
'''
hook_source = '''
    lua <<EOF
        require'hop'.setup {
            create_hl_autocmd = true,
        }
EOF
'''

[[plugins]]
repo = 'tpope/vim-speeddating'
on_map = ['<C-a>', '<C-x>']

[[plugins]]
repo = 'tpope/vim-repeat'

[[plugins]]
repo = 'dhruvasagar/vim-table-mode'
on_map = { n = '<Space>t' } # Cannot use `<Leader>`
hook_source = '''
    " let g:table_mode_corner_corner = '+'
    " let g:table_mode_header_fillchar = '='
'''

[[plugins]]
repo = 'L3MON4D3/LuaSnip'
on_lua = 'luasnip'
hook_source = '''
    inoremap <silent> <C-j> <Cmd>lua require'luasnip'.jump(1)<CR>
    inoremap <silent> <C-k> <Cmd>lua require'luasnip'.jump(-1)<CR>

    snoremap <silent> <C-j> <Cmd>lua require'luasnip'.jump(1)<CR>
    snoremap <silent> <C-k> <Cmd>lua require'luasnip'.jump(-1)<CR>
'''

[[plugins]]
repo = 'hrsh7th/nvim-compe'
on_event = 'InsertEnter'
hook_source = '''
    lua <<EOF
        vim.o.completeopt = 'menuone,noselect'

        require'compe'.setup {
            preselect = 'always',
            documentation = {
                border = 'rounded',
                winhighlight = 'NormalFloat:NormalFloat,FloatBorder:FloatBorder',
            },
            source = {
                path = {
                    kind = ' ',
                },
                buffer = {
                    kind = ' ',
                    menu = '[B]',
                },
                calc = {
                    kind = ' ',
                },
                nvim_lsp = true,
                nvim_lua = true,
                luasnip = {
                    kind = ' ',
                    menu = '[SNIP]',
                },
            },
        }

        local regex_start_with_nonspace = vim.regex([[^\S]])
        _G.super_tab = function()
            if vim.fn.pumvisible() ~= 0 then
                local break_undo = vim.api.nvim_replace_termcodes('<C-g>u', true, true, true)
                return break_undo .. vim.fn['compe#confirm']('<Tab>')
            end

            local row, col = unpack(vim.api.nvim_win_get_cursor(0))
            if col > 0 and regex_start_with_nonspace:match_line(0, row - 1, col - 1) then
                return vim.fn['compe#complete']()
            end

            return vim.api.nvim_replace_termcodes('<Tab>', true, true, true)
        end

        local opts = {
            noremap = true,
            silent = true,
            expr = true,
        }

        vim.api.nvim_set_keymap('i', '<Tab>', [[v:lua.super_tab()]], opts)
        vim.api.nvim_set_keymap('i', '<C-g>', [[compe#close()]], opts)
EOF
'''

[[plugins]]
repo = 'ray-x/lsp_signature.nvim'
on_lua = 'lsp_signature'

[[plugins]]
repo = 'simrat39/rust-tools.nvim'
on_lua = 'rust-tools'

[[plugins]]
repo = 'kabouzeid/nvim-lspinstall'
on_lua = 'lspinstall'
hook_source = '''
    lua <<END
        -- Reinstall/update specified language servers, work with headless
        _G.lsp_install_headless = function(lang)
            local servers = require'lspinstall.servers'
            local install_path = require'lspinstall.util'.install_path

            print('Install lsp ' .. lang .. '\n')

            local shell = vim.o.shell
            vim.o.shell = '/usr/bin/env bash'

            local function output_callback(job, data, event)
                -- `print()` cannot treat multiple newlines
                vim.api.nvim_echo({{ table.concat(data, '\n'), 'None' }}, true, {})
            end

            local job = vim.fn.jobstart('set -e; ' .. servers[lang].install_script, {
                cwd = install_path(lang),
                on_stdout = output_callback,
                on_stderr = output_callback,
            })
            if job <= 0 then
                print('jobstart failed with ' .. job .. '\n')
                return
            end

            vim.o.shell = shell

            vim.fn.jobwait { job }
        end

        -- Reinstall/update all installed language servers, work with headless
        _G.lsp_reinstall_all_headless = function()
            local lspinstall = require'lspinstall'
            for _, lsp in ipairs(lspinstall.installed_servers()) do
                _G.lsp_install_headless(lsp)
            end
        end
END
'''

[[plugins]]
repo = 'neovim/nvim-lspconfig'
# Initialize after `:syntax enable` to do LSP formatting correctly
on_event = 'Syntax'
hook_source = '''
    lua <<EOF
        local nvim_lsp = require'lspconfig'
        local lspconfig_configs = require'lspconfig/configs'
        local lspinstall = require'lspinstall'
        local lspinstall_servers = require'lspinstall.servers'
        local lspinstall_install_path = require'lspinstall.util'.install_path

        local signature_config = {
            hint_prefix = ' ',
        }

        -- This can override in project configuration
        vim.g.autoformat_disable_ft = {}

        _G.autoformat = function()
            local function to_bool(x)
                return x and x ~= 0
            end

            if to_bool(vim.b.autoformat_disable) then
                return
            end

            if not to_bool(vim.b.autoformat_enable) then
                if vim.tbl_contains(vim.g.autoformat_disable_ft, vim.bo.filetype) then
                    return
                end

                if not vim.tbl_contains(vim.g.autoformat_enable_ft, vim.bo.filetype) then
                    return
                end
            end

            vim.lsp.buf.formatting_sync(nil, 1000)
        end

        local function on_attach(client, bufnr)
            require'lsp_signature'.on_attach(signature_config)

            local function buf_set_keymap(...)
                vim.api.nvim_buf_set_keymap(bufnr, ...)
            end

            local opts = {
                noremap = true,
                silent = true,
            }

            buf_set_keymap('n', 'gd',
                [[<Cmd>lua require('telescope.builtin').lsp_definitions {}<CR>]], opts)
            buf_set_keymap('n', 'gD', '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
            buf_set_keymap('n', 'gi',
                [[<Cmd>lua require('telescope.builtin').lsp_implementations {}<CR>]], opts)
            buf_set_keymap('n', 'g<C-d>', '<Cmd>lua vim.lsp.buf.type_definition()<CR>', opts)

            buf_set_keymap('n', '<M-y>',
                [[<Cmd>lua require('telescope.builtin').lsp_document_symbols {}<CR>]], opts)
            buf_set_keymap('n', '<M-Y>',
                [[<Cmd>lua require('telescope.builtin').lsp_workspace_symbols {}<CR>]], opts)
            buf_set_keymap('n', 'gr', '<Cmd>lua vim.lsp.buf.reference()<CR>', opts)
            buf_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
            buf_set_keymap('n', '<C-k>', '<Cmd>lua vim.lsp.buf.signature_help()<CR>', opts)

            buf_set_keymap('n', 'gf', '<Cmd>lua vim.lsp.buf.formatting()<CR>', opts)
            buf_set_keymap('x', 'gf', '<Cmd>lua vim.lsp.buf.range_formatting()<CR>', opts)

            buf_set_keymap('n', 'gn', '<Cmd>lua vim.lsp.buf.rename()<CR>', opts)
            buf_set_keymap('n', '<Leader>a',
                [[<Cmd>lua require('telescope.builtin').lsp_code_actions {}<CR>]], opts)

            buf_set_keymap('n', '<M-a>',
                [[<Cmd>lua require('telescope.builtin').lsp_document_diagnostics {}<CR>]], opts)
            buf_set_keymap('n', '<M-A>',
                [[<Cmd>lua require('telescope.builtin').lsp_workspace_diagnostics {}<CR>]], opts)
            buf_set_keymap('n', '[d', '<Cmd>lua vim.lsp.diagnostic.goto_prev { wrap = false }<CR>', opts)
            buf_set_keymap('n', ']d', '<Cmd>lua vim.lsp.diagnostic.goto_next { wrap = false }<CR>', opts)
            buf_set_keymap('x', '[d', '<Cmd>lua vim.lsp.diagnostic.goto_prev { wrap = false }<CR>', opts)
            buf_set_keymap('x', ']d', '<Cmd>lua vim.lsp.diagnostic.goto_next { wrap = false }<CR>', opts)

            vim.b.autoformat_disable = false
            vim.b.autoformat_enable = false

            vim.cmd [[
                augroup config_lsp_buf
                    autocmd!
                    autocmd BufWritePre <buffer> call v:lua.autoformat()
                augroup end
            ]]

            vim.lsp.handlers['textDocument/hover'] =
                vim.lsp.with(vim.lsp.handlers.hover, { border = 'rounded' })
        end

        local capabilities = vim.lsp.protocol.make_client_capabilities()
        capabilities.textDocument.completion.completionItem.snippetSupport = true
        capabilities.textDocument.completion.completionItem.resolveSupport = {
            properties = {
                'documentation',
                'detail',
                'additionalTextEdits',
            }
        }

        local settings = {
            ["rust-analyzer"] = {
                checkOnSave = {
                    command = 'clippy',
                },
            },
        }

        local servers = {
            bashls = {
                lspinstall = 'bash',
            },
            clangd = {
                autoformat = { 'c', 'cpp' },
                lspinstall = 'cpp',
            },
            dockerls = {
                lspinstall = 'dockerfile',
            },
            jsonls = {
                autoformat = { 'json' },
                lspinstall = 'json',
            },
            pyright = {
                autoformat = { 'python' },
                lspinstall = 'python',
            },
            rust_analyzer = {
                autoformat = { 'rust' },
                lspinstall = 'rust',
                on_attach = function(client, bufnr)
                    vim.cmd [[
                        augroup config_lsp_rust_buf
                            autocmd!
                            autocmd CursorMoved,InsertLeave,BufEnter,BufWinEnter,TabEnter,BufWritePost <buffer> lua require'rust-tools.inlay_hints'.set_inlay_hints()
                        augroup end
                    ]]
                end,
                setup = function(opts)
                    require'rust-tools'.setup {
                        tools = {
                            autoSetHints = false,
                        },
                        server = opts,
                    }
                end,
            },
            tailwindcss = {
                lspinstall = 'tailwindcss',
            },
            texlab = {
                lspinstall = 'latex',
            },
            vimls = {
                lspinstall = 'vim',
            },
            efm = {
                lspinstall = 'efm',
                config = {
                    filetypes = { 'python' },
                    init_options = {
                        documentFormatting = true,
                    },
                    settings = {
                        rootMarkers = { '.git' },
                        languages = {
                            python = {
                                {
                                    formatCommand = 'black --quiet -',
                                    formatStdin = true,
                                },
                            },
                        },
                    },
                },
            },
        }

        vim.g.autoformat_enable_ft = {}

        for lang, config in pairs(servers) do
            if config.autoformat then
                vim.g.autoformat_enable_ft = vim.list_extend(vim.g.autoformat_enable_ft, config.autoformat)
            end

            require('lspconfig.' .. lang)
            local cmd = lspconfig_configs[lang].document_config.default_config.cmd
            if config.lspinstall then
                local lang_ = config.lspinstall
                if lspinstall.is_server_installed(lang_) then
                    cmd = lspinstall_servers[lang_].default_config.cmd
                    if vim.regex([[^\.\{1,2}\/]]):match_str(cmd[1]) then
                        cmd[1] = lspinstall_install_path(lang_) .. '/' .. cmd[1]
                    end
                end
            end
            vim.list_extend(cmd, config.args or {})

            local attach = on_attach
            if config.on_attach then
                local config_on_attach = config.on_attach
                attach = function(client, bufnr)
                    on_attach(client, bufnr)
                    config_on_attach(client, bufnr)
                end
            end

            local opts = vim.tbl_deep_extend(
                'keep',
                config.config or {},
                {
                    cmd = cmd,
                    capabilities = capabilities,
                    settings = settings,
                    on_attach = attach,
                }
            )

            local setup = nvim_lsp[lang].setup
            if config.setup then
                setup = config.setup
            end

            setup(opts)
        end

        local signs = {
            Error = ' ',
            Warning = ' ',
            Hint = ' ',
            Information = ' ',
        }

        for type, text in pairs(signs) do
            local hl = 'LspDiagnosticsSign' .. type
            vim.fn.sign_define(hl, { text = text, texthl = hl, numhl = '' })
        end

        local kinds = {
            Text          = ' ',
            Method        = ' ',
            Function      = 'ƒ ',
            Constructor   = ' ',
            Field         = ' ',
            Variable      = ' ',
            Class         = ' ',
            Interface     = ' ',
            Module        = ' ',
            Property      = ' ',
            Unit          = ' ',
            Value         = ' ',
            Enum          = ' ',
            Keyword       = ' ',
            Snippet       = ' ',
            Color         = ' ',
            File          = ' ',
            Reference     = ' ',
            Folder        = ' ',
            EnumMember    = ' ',
            Constant      = ' ',
            Struct        = ' ',
            Event         = ' ',
            Operator      = ' ',
            TypeParameter = ' ',
        }

        for name, str in pairs(kinds) do
            if vim.lsp.protocol.CompletionItemKind[name] ~= nil then
                vim.lsp.protocol.CompletionItemKind[vim.lsp.protocol.CompletionItemKind[name]] = str
            end
        end

        vim.cmd [[
            augroup config_lsp
                autocmd!
                " Set rounded border to the window opened by `LspInfo`
                autocmd FileType lspinfo call nvim_win_set_config(0, { 'border': 'rounded' })
            augroup end
        ]]
EOF
'''
